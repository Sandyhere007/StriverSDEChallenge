
// Recursive solution
// #include <bits/stdc++.h> 
// int countPaths(int i , int j , int m , int n){
// 	if(i==(m-1)&& j== (n-1)) return 1;
// 	if(i>=m || j>=n) return 0;

// 	else{
// 		return countPaths(i+1,j,m,n)+countPaths(i,j+1,m,n);
// 	}
// }

// int uniquePaths(int m, int n) {
// 	// Write your code here.
// 	countPaths(0 , 0 , m , n);
// }
// Dynamic Programming solution 
// #include <bits/stdc++.h> 
// int countPaths(int i , int j , int m , int n,vector<vector<int>> &dp){
// 	if(i==(m-1)&& j== (n-1)) return 1;
// 	if(i>=m || j>=n) return 0;
// 	if(dp[i][j]!=-1) return dp[i][j];
// 	else{
// 		return dp[i][j] = countPaths(i+1,j,m,n,dp)+countPaths(i,j+1,m,n,dp);
// 	}
// }

// int uniquePaths(int m, int n) {
// 	// Write your code here.
// 	vector<vector<int>> dp(m+1,vector<int>(n+1,-1));
// 	int num = countPaths(0 , 0 , m , n, dp);
// 	if(m==1 &&n==1) return num;
// 	return dp[0][0];
// }


// combinatorial solution 
// find combination with N =M+N-2; and r as n-1 or m-1
#include <bits/stdc++.h> 

int uniquePaths(int m, int n) {
	int N = m+n-2;
	int r = m-1;
	double res = 1;
	for(int i = 1; i<=r ; i++){
		res = res*(N-r+i)/i;
	}

	return (int)res;
}

